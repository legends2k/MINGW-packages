diff -urN pywin32-b306-orig/win32/src/PerfMon/PyPerfMon.cpp pywin32-b306/win32/src/PerfMon/PyPerfMon.cpp
--- pywin32-b306-orig/win32/src/PerfMon/PyPerfMon.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/PerfMon/PyPerfMon.cpp	2023-04-07 09:30:09.612441600 +0800
@@ -13,7 +13,7 @@
 ******************************************************************/
 
 #include "PyWinTypes.h"
-#include "Pyperfmon.h"
+#include "pyperfmon.h"
 #include "tchar.h"
 
 extern PyObject *PerfmonMethod_NewPERF_COUNTER_DEFINITION(PyObject *self, PyObject *args);
diff -urN pywin32-b306-orig/win32/src/PerfMon/PyPerfMonControl.h pywin32-b306/win32/src/PerfMon/PyPerfMonControl.h
--- pywin32-b306-orig/win32/src/PerfMon/PyPerfMonControl.h	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/PerfMon/PyPerfMonControl.h	2023-04-07 09:30:09.624439400 +0800
@@ -18,6 +18,6 @@
     DWORD ControlSize;  // Size of this structure.
     DWORD TotalSize;    // Total Size allocated in the mapped file.
     SupplierStatus supplierStatus;
-    WCHAR ServiceName[MMCD_SERVICE_SIZE];          // The name of the service or application.
-    WCHAR EventSourceName[MMCD_EVENTSOURCE_SIZE];  // Source Name that appears in Event Log for errors.
+    WCHAR ServiceName[MMCD_SERVICE_SIZE+1];          // The name of the service or application.
+    WCHAR EventSourceName[MMCD_EVENTSOURCE_SIZE+1];  // Source Name that appears in Event Log for errors.
 };
diff -urN pywin32-b306-orig/win32/src/PerfMon/PyPerfMsgs.mc pywin32-b306/win32/src/PerfMon/PyPerfMsgs.mc
--- pywin32-b306-orig/win32/src/PerfMon/PyPerfMsgs.mc	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/PerfMon/PyPerfMsgs.mc	2023-04-07 09:30:09.634400100 +0800
@@ -86,3 +86,4 @@
 .
 ;//
 ;#endif // _PYPERFMSG_H_
+
diff -urN pywin32-b306-orig/win32/src/PyHANDLE.cpp pywin32-b306/win32/src/PyHANDLE.cpp
--- pywin32-b306-orig/win32/src/PyHANDLE.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/PyHANDLE.cpp	2023-04-07 09:30:30.398988500 +0800
@@ -129,7 +129,11 @@
     PyHANDLE::binaryFailureFunc, /* nb_xor */
     PyHANDLE::binaryFailureFunc, /* nb_or */
     PyHANDLE::intFunc,          /* nb_int */
+#if (PY_VERSION_HEX < 0x03000000)
     PyHANDLE::longFunc,         /* nb_long */
+#else
+    0,
+#endif
     PyHANDLE::unaryFailureFunc, /* nb_float */
                                 // These removed in 3.0
 };
diff -urN pywin32-b306-orig/win32/src/PyWinTypes.h pywin32-b306/win32/src/PyWinTypes.h
--- pywin32-b306-orig/win32/src/PyWinTypes.h	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/PyWinTypes.h	2023-04-07 09:30:41.318120800 +0800
@@ -18,6 +18,18 @@
 #include "structmember.h"
 #include "windows.h"
 
+#ifndef _MSC_VER
+#define min(x,y) (((x) < (y)) ? (x) : (y))
+#define max(x,y) (((x) > (y)) ? (x) : (y))
+
+#ifndef __try
+#define __try try
+#endif
+#ifndef __except
+#define __except(filter) catch(...)
+#endif
+#endif
+
 // Helpers for our modules.
 // Some macros to help the pywin32 modules co-exist in py2x and py3k.
 // Creates and initializes local variables called 'module' and 'dict'.
diff -urN pywin32-b306-orig/win32/src/PyWinTypesmodule.cpp pywin32-b306/win32/src/PyWinTypesmodule.cpp
--- pywin32-b306-orig/win32/src/PyWinTypesmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/PyWinTypesmodule.cpp	2023-04-07 09:30:41.350131400 +0800
@@ -1087,11 +1087,17 @@
 }
 
 // Function to format a python traceback into a character string.
+#ifdef _MSC_VER
 #define GPEM_ERROR(what)                                     \
     {                                                        \
         errorMsg = L"<Error getting traceback - "##what##">"; \
-        goto done;                                           \
     }
+#else
+#define GPEM_ERROR(what)                                     \
+    {                                                        \
+        errorMsg = L"<Error getting traceback - " what ">";  \
+    }
+#endif
 PYWINTYPES_EXPORT WCHAR *GetPythonTraceback(PyObject *exc_type, PyObject *exc_value, PyObject *exc_tb)
 {
     WCHAR *result = NULL;
@@ -1110,22 +1116,27 @@
 
     if (modStringIO == NULL)
         GPEM_ERROR("cant import cStringIO");
+        Py_XDECREF(modStringIO);
     modTB = PyImport_ImportModule("traceback");
     if (modTB == NULL)
         GPEM_ERROR("cant import traceback");
+        Py_XDECREF(modTB);
 
     /* Construct a cStringIO object */
     obFuncStringIO = PyObject_GetAttrString(modStringIO, "StringIO");
     if (obFuncStringIO == NULL)
         GPEM_ERROR("cant find cStringIO.StringIO");
+        Py_XDECREF(obFuncStringIO);
     obStringIO = PyObject_CallObject(obFuncStringIO, NULL);
     if (obStringIO == NULL)
         GPEM_ERROR("cStringIO.StringIO() failed");
+        Py_XDECREF(obStringIO);
 
     /* Get the traceback.print_exception function, and call it. */
     obFuncTB = PyObject_GetAttrString(modTB, "print_exception");
     if (obFuncTB == NULL)
         GPEM_ERROR("cant find traceback.print_exception");
+        Py_XDECREF(obFuncTB);
     // Py3k has added an undocumented 'chain' argument which defaults to True
     // and causes all kinds of exceptions while trying to print a traceback!
     // This *could* be useful thought if we can tame it - later!
@@ -1140,6 +1151,7 @@
     );
     if (argsTB == NULL)
         GPEM_ERROR("cant make print_exception arguments");
+        Py_XDECREF(argsTB);
 
     obResult = PyObject_CallObject(obFuncTB, argsTB);
     if (obResult == NULL) {
@@ -1150,32 +1162,27 @@
         // PyUnicodeObject *uo=(PyUnicodeObject *)v;
         // DebugBreak();
         GPEM_ERROR("traceback.print_exception() failed");
+        Py_XDECREF(obResult);
     }
     /* Now call the getvalue() method in the StringIO instance */
     Py_DECREF(obFuncStringIO);
     obFuncStringIO = PyObject_GetAttrString(obStringIO, "getvalue");
     if (obFuncStringIO == NULL)
         GPEM_ERROR("cant find getvalue function");
+        Py_XDECREF(obFuncStringIO);
     Py_DECREF(obResult);
     obResult = PyObject_CallObject(obFuncStringIO, NULL);
     if (obResult == NULL)
         GPEM_ERROR("getvalue() failed.");
+        Py_XDECREF(obResult);
 
     /* And it should be a string all ready to go - duplicate it. */
     if (PyWinObject_AsWCHAR(obResult, &resultPtr, FALSE))
         result = wcsdup(resultPtr);
     else
         GPEM_ERROR("getvalue() did not return a string");
+        if (result == NULL && errorMsg != NULL)
+            result = wcsdup(errorMsg);
 
-done:
-    if (result == NULL && errorMsg != NULL)
-        result = wcsdup(errorMsg);
-    Py_XDECREF(modStringIO);
-    Py_XDECREF(modTB);
-    Py_XDECREF(obFuncStringIO);
-    Py_XDECREF(obStringIO);
-    Py_XDECREF(obFuncTB);
-    Py_XDECREF(argsTB);
-    Py_XDECREF(obResult);
     return result;
 }
diff -urN pywin32-b306-orig/win32/src/PythonService.cpp pywin32-b306/win32/src/PythonService.cpp
--- pywin32-b306-orig/win32/src/PythonService.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/PythonService.cpp	2023-04-07 09:30:41.385168300 +0800
@@ -1302,7 +1302,7 @@
 
     TCHAR cvtBuf[20];
     wsprintf(cvtBuf, L"%d", errCode);
-    LPTSTR lpszStrings[] = {cvtBuf, buf, L'\0'};
+    LPTSTR lpszStrings[] = {cvtBuf, buf, L"\0"};
     ReportError(msgCode, (LPCTSTR *)lpszStrings);
 }
 
diff -urN pywin32-b306-orig/win32/src/PythonServiceMessages.mc pywin32-b306/win32/src/PythonServiceMessages.mc
--- pywin32-b306-orig/win32/src/PythonServiceMessages.mc	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/PythonServiceMessages.mc	2023-04-07 09:30:41.428148900 +0800
@@ -137,7 +137,7 @@
 Severity=Error
 SymbolicName=E_UNUSED2
 Language=English
-
+Unknown error.
 .
 
 MessageId=0x8
diff -urN pywin32-b306-orig/win32/src/_winxptheme.i pywin32-b306/win32/src/_winxptheme.i
--- pywin32-b306-orig/win32/src/_winxptheme.i	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/_winxptheme.i	2023-04-07 09:30:41.443119100 +0800
@@ -15,12 +15,14 @@
 %include "pywintypes.i"
 
 %{
+#undef _WIN32_IE
 #define _WIN32_IE 0x0501 // to enable balloon notifications in Shell_NotifyIcon
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0501
 //#define ISOLATION_AWARE_ENABLED 1
 
 #undef PyHANDLE
-#include "pywinobjects.h"
+#include "PyWinObjects.h"
 #include "windows.h"
 #include "Uxtheme.h"
 #include "commctrl.h"
@@ -93,6 +95,8 @@
 		return NULL;
 }
 
+%typedef RECT RECT;
+
 %typemap(python,ignore) RECT *OUTPUT(RECT temp)
 {
   $target = &temp;
diff -urN pywin32-b306-orig/win32/src/mmapfilemodule.cpp pywin32-b306/win32/src/mmapfilemodule.cpp
--- pywin32-b306-orig/win32/src/mmapfilemodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/mmapfilemodule.cpp	2023-04-07 09:30:41.474125500 +0800
@@ -71,7 +71,7 @@
 {
     char *where = (self->data + self->pos);
     CHECK_VALID;
-    if ((where >= 0) && (where < (self->data + self->size))) {
+    if (((INT_PTR)where >= 0) && (where < (self->data + self->size))) {
         PyObject *ret = PyBytes_FromStringAndSize(where, 1);
         if (ret)
             self->pos += 1;
diff -urN pywin32-b306-orig/win32/src/odbc.cpp pywin32-b306/win32/src/odbc.cpp
--- pywin32-b306-orig/win32/src/odbc.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/odbc.cpp	2023-04-07 09:30:41.500137000 +0800
@@ -93,8 +93,8 @@
 static cursorObject *cursor(PyObject *o) { return (cursorObject *)o; }
 
 static void cursorDealloc(PyObject *self);
-PyMethodDef cursorMethods[];
-PyMemberDef cursorMembers[];
+extern PyMethodDef cursorMethods[];
+extern PyMemberDef cursorMembers[];
 
 static PyTypeObject Cursor_Type = {
     PYWIN_OBJECT_HEAD "odbccur", /*tp_name */
@@ -137,8 +137,8 @@
 };
 
 static void connectionDealloc(PyObject *self);
-PyMethodDef connectionMethods[];
-PyMemberDef connectionMembers[];
+extern PyMethodDef connectionMethods[];
+extern PyMemberDef connectionMembers[];
 static PyTypeObject Connection_Type = {
     PYWIN_OBJECT_HEAD "odbcconn", /*tp_name */
     sizeof(connectionObject),     /*tp_basicsize */
@@ -379,7 +379,7 @@
 }
 
 /* @object connection|An object representing an ODBC connection */
-static struct PyMethodDef connectionMethods[] = {
+struct PyMethodDef connectionMethods[] = {
     {"setautocommit", odbcSetAutoCommit, 1}, /* @pymeth setautocommit|Sets the autocommit mode. */
     {"commit", odbcCommit, 1},               /* @pymeth commit|Commits a transaction. */
     {"rollback", odbcRollback, 1},           /* @pymeth rollback|Rollsback a transaction. */
@@ -387,7 +387,7 @@
     {"close", odbcClose, 1},                 /* @pymeth close|Closes the connection. */
     {0, 0}};
 
-static PyMemberDef connectionMembers[] = {{"error", T_OBJECT, offsetof(connectionObject, connectionError), READONLY},
+struct PyMemberDef connectionMembers[] = {{"error", T_OBJECT, offsetof(connectionObject, connectionError), READONLY},
                                           {NULL}};
 
 static void connectionDealloc(PyObject *self)
@@ -1418,7 +1418,7 @@
 }
 
 /* @object cursor|An object representing an ODBC cursor. */
-static PyMethodDef cursorMethods[] = {
+struct PyMethodDef cursorMethods[] = {
     {"close", odbcCurClose, 1},                 /* @pymeth close|Closes the cursor */
     {"execute", odbcCurExec, 1},                /* @pymeth execute|Execute some SQL */
     {"fetchone", odbcCurFetchOne, 1},           /* @pymeth fetchone|Fetch one row of data */
@@ -1428,7 +1428,7 @@
     {"setoutputsize", odbcCurSetOutputSize, 1}, /* @pymeth setoutputsize| */
     {0, 0}};
 
-static PyMemberDef cursorMembers[] = {{"description", T_OBJECT, offsetof(cursorObject, description), READONLY},
+struct PyMemberDef cursorMembers[] = {{"description", T_OBJECT, offsetof(cursorObject, description), READONLY},
                                       {"error", T_OBJECT, offsetof(cursorObject, cursorError), READONLY},
                                       {NULL}};
 
@@ -1448,13 +1448,25 @@
 
     if (!firstEqualsSign || (firstSlash && firstSlash < firstEqualsSign)) {
         _tcsncpy(buf, c, sizeof(buf) / sizeof(TCHAR));
+#ifdef _UCRT
+        p = _tcstok(buf, _T("/"), 0);
+#else
         p = _tcstok(buf, _T("/"));
+#endif
         if (p) {
             _tcsncpy(dsn, p, sizeof(dsn) / sizeof(TCHAR));
+#ifdef _UCRT
+            p = _tcstok(buf, _T("/"), 0);
+#else
             p = _tcstok(0, _T("/"));
+#endif
             if (p) {
                 _tcsncpy(uid, p, sizeof(uid) / sizeof(TCHAR));
+#ifdef _UCRT
+                p = _tcstok(buf, _T("/"), 0);
+#else
                 p = _tcstok(0, _T("/"));
+#endif
                 if (p) {
                     _tcsncpy(pwd, p, sizeof(pwd) / sizeof(TCHAR));
                 }
diff -urN pywin32-b306-orig/win32/src/timermodule.cpp pywin32-b306/win32/src/timermodule.cpp
--- pywin32-b306-orig/win32/src/timermodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/timermodule.cpp	2023-04-07 09:30:41.513120500 +0800
@@ -8,7 +8,7 @@
 
 // @doc - Contains autoduck comments for documentation
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 //#include "abstract.h"
 
 static PyObject *timer_id_callback_map = NULL;
diff -urN pywin32-b306-orig/win32/src/win32apimodule.cpp pywin32-b306/win32/src/win32apimodule.cpp
--- pywin32-b306-orig/win32/src/win32apimodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32apimodule.cpp	2023-04-07 09:30:41.555130500 +0800
@@ -528,7 +528,7 @@
             if (rc == (HINSTANCE)31)
                 PyErr_SetString(PyWinExc_ApiError, "FindExecutable: There is no association for the file");
             else
-                PyWin_SetAPIError("FindExecutable", (int)rc);
+                PyWin_SetAPIError("FindExecutable", (INT_PTR)rc);
         }
         else ret = Py_BuildValue("(NN)", PyWinLong_FromHANDLE(rc), PyWinObject_FromTCHAR(res));
     }
@@ -1173,7 +1173,7 @@
     if (!PyWinObject_AsResourceId(obid, &id))
         return NULL;
     // @pyseeapi LoadCursor
-    PyW32_BEGIN_ALLOW_THREADS HCURSOR ret = ::LoadCursor(hInstance, MAKEINTRESOURCE(id));
+    PyW32_BEGIN_ALLOW_THREADS HCURSOR ret = ::LoadCursor(hInstance, MAKEINTRESOURCE((ULONG_PTR)id));
     PyW32_END_ALLOW_THREADS PyWinObject_FreeResourceId(id);
     if (ret == NULL)
         ReturnAPIError("LoadCursor");
@@ -1780,7 +1780,7 @@
     if (proc == NULL)
         return ReturnAPIError("GetProcAddress");
     // @pyseeapi GetProcAddress
-    return PyWinLong_FromVoidPtr(proc);
+    return PyWinLong_FromVoidPtr((PVOID)proc);
 }
 
 // @pymethod <o PyUnicode>|win32api|GetDllDirectory|Returns the DLL search path
@@ -4298,7 +4298,7 @@
         PyW32_BEGIN_ALLOW_THREADS HINSTANCE rc = ::ShellExecute(hwnd, op, file, params, dir, show);
         PyW32_END_ALLOW_THREADS
             // @pyseeapi ShellExecute
-            if (rc <= (HINSTANCE)32) PyWin_SetAPIError("ShellExecute", (int)rc);
+            if (rc <= (HINSTANCE)32) PyWin_SetAPIError("ShellExecute", (INT_PTR)rc);
         else ret = PyWinLong_FromVoidPtr(rc);
     }
     PyWinObject_FreeTCHAR(op);
@@ -5277,8 +5277,8 @@
     }
     PyThreadState *stateSave = PyThreadState_Swap(NULL);
     PyThreadState_Swap(stateSave);
-    _try { ret = PyObject_CallObject(obFunc, obArgs); }
-    _except(PyApplyExceptionFilter(GetExceptionCode(), GetExceptionInformation(), obHandler, &exc_type, &exc_value))
+    __try { ret = PyObject_CallObject(obFunc, obArgs); }
+    __except(PyApplyExceptionFilter(GetExceptionCode(), GetExceptionInformation(), obHandler, &exc_type, &exc_value))
     {
         // Do my best to restore the thread state to a sane spot.
         PyThreadState *stateCur = PyThreadState_Swap(NULL);
diff -urN pywin32-b306-orig/win32/src/win32clipboardmodule.cpp pywin32-b306/win32/src/win32clipboardmodule.cpp
--- pywin32-b306-orig/win32/src/win32clipboardmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32clipboardmodule.cpp	2023-04-07 09:30:41.580132800 +0800
@@ -15,7 +15,7 @@
 
 #define PY_SSIZE_T_CLEAN  // this should be Py_ssize_t clean!
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 
 #define CHECK_NO_ARGS2(args, fnName)              \
     do {                                          \
@@ -1098,12 +1098,11 @@
     {NULL, NULL}};
 
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 
 static int AddConstants(PyObject *module)
 {
-    int rc;
     ADD_CONSTANT(CF_TEXT);
     ADD_CONSTANT(CF_BITMAP);
     ADD_CONSTANT(CF_METAFILEPICT);
diff -urN pywin32-b306-orig/win32/src/win32consolemodule.cpp pywin32-b306/win32/src/win32consolemodule.cpp
--- pywin32-b306-orig/win32/src/win32consolemodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32consolemodule.cpp	2023-04-07 09:30:41.611133800 +0800
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x501
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
diff -urN pywin32-b306-orig/win32/src/win32credmodule.cpp pywin32-b306/win32/src/win32credmodule.cpp
--- pywin32-b306-orig/win32/src/win32credmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32credmodule.cpp	2023-04-07 09:30:41.635134700 +0800
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x501  // Credentials functions only available on WinXP
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
diff -urN pywin32-b306-orig/win32/src/win32crypt/win32cryptmodule.cpp pywin32-b306/win32/src/win32crypt/win32cryptmodule.cpp
--- pywin32-b306-orig/win32/src/win32crypt/win32cryptmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32crypt/win32cryptmodule.cpp	2023-04-07 09:30:41.663164200 +0800
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x502
 #include "win32crypt.h"
 
@@ -584,6 +585,7 @@
         pvPara = (void *)&cssrp;
     }
     else {
+#ifdef _MSC_VER
         switch ((ULONG_PTR)StoreProvider) {
             case CERT_STORE_PROV_PHYSICAL:
             case CERT_STORE_PROV_FILENAME:
@@ -625,6 +627,41 @@
                 return NULL;
             }
         }
+#else
+        if (StoreProvider == CERT_STORE_PROV_PHYSICAL)
+        if (StoreProvider == CERT_STORE_PROV_FILENAME)
+        if (StoreProvider == CERT_STORE_PROV_SYSTEM)
+        if (StoreProvider == CERT_STORE_PROV_SYSTEM_REGISTRY)
+        if (StoreProvider == CERT_STORE_PROV_LDAP) {
+            if (!PyWinObject_AsWCHAR(obpvPara, (WCHAR **)&pvPara))
+                return NULL;
+            free_wchar = TRUE;
+	}
+        if (StoreProvider == CERT_STORE_PROV_REG) {
+            if (!PyWinObject_AsHKEY(obpvPara, (HKEY *)&pvPara))
+                return NULL;
+	}
+        if (StoreProvider == CERT_STORE_PROV_FILE) {
+            if (!PyWinObject_AsHANDLE(obpvPara, (HANDLE *)&pvPara))
+                return NULL;
+	}
+        if (StoreProvider == CERT_STORE_PROV_SERIALIZED)
+        if (StoreProvider == CERT_STORE_PROV_PKCS7) {
+            if (!pybuf.init(obpvPara))
+                return NULL;
+            crypt_data_blob.pbData = (BYTE*)pybuf.ptr();
+            crypt_data_blob.cbData = pybuf.len();
+            pvPara = (void *)&crypt_data_blob;
+	}
+        if (StoreProvider == CERT_STORE_PROV_MEMORY) {
+            // pvPara is not used, warn if something passed in
+            if (obpvPara != Py_None)
+                PyErr_Warn(PyExc_RuntimeWarning, "Para ignored for CERT_STORE_PROV_MEMORY");
+	}
+
+        PyErr_SetString(PyExc_NotImplementedError, "Specified store provider type not supported");
+        return NULL;
+#endif
     }
 
     Py_BEGIN_ALLOW_THREADS hcertstore = CertOpenStore(StoreProvider, dwEncodingType, hcryptprov, dwFlags, pvPara);
diff -urN pywin32-b306-orig/win32/src/win32dynamicdialog.cpp pywin32-b306/win32/src/win32dynamicdialog.cpp
--- pywin32-b306-orig/win32/src/win32dynamicdialog.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32dynamicdialog.cpp	2023-04-07 09:30:41.692131000 +0800
@@ -31,7 +31,7 @@
 
 #ifdef WIN32GUI  // being compiled from WIN32GUI
 #define PYW_EXPORT
-#include "python.h"
+#include "Python.h"
 #undef PyHANDLE
 #include <windows.h>
 #include "commctrl.h"
@@ -40,8 +40,8 @@
 #ifdef MS_WINCE
 #include "winbase.h"
 #endif
-#include "pywintypes.h"
-#include "pywinobjects.h"
+#include "PyWinTypes.h"
+#include "PyWinObjects.h"
 #include "tchar.h"
 
 #define BASED_CODE
@@ -54,7 +54,7 @@
 #endif
 
 #include "win32dynamicdialog.h"
-static void DwordAlign(PCHAR *ptr)
+void DwordAlign(PCHAR *ptr)
 {
     size_t offset = ((ULONG_PTR)*ptr) & 0x03;
     if (offset > 0) {
@@ -214,7 +214,7 @@
 
 HGLOBAL CPythonDialogTemplate::ClaimTemplate()
 {
-    register HGLOBAL h = m_h;
+    HGLOBAL h = m_h;
     m_h = NULL;
     m_alloc = 0;
     m_len = 0;
@@ -600,7 +600,7 @@
         goto cleanup;
 
     if (IS_INTRESOURCE(wclass))
-        ret = dlg->Add((WORD)wclass, &tpl, caption);
+        ret = dlg->Add((DWORD_PTR)wclass, &tpl, caption);
     else
         ret = dlg->Add(wclass, &tpl, caption, pybuf.len(), (BYTE*)pybuf.ptr());
 
@@ -631,7 +631,7 @@
     if (dlg == NULL)
         return NULL;
 
-    for (register Py_ssize_t i = 1; i < size; i++) {
+    for (Py_ssize_t i = 1; i < size; i++) {
         if (!ParseDlgItemList(dlg, PyTuple_GET_ITEM(obdlg, i))) {
             delete dlg;
             Py_DECREF(obdlg);
diff -urN pywin32-b306-orig/win32/src/win32event.i pywin32-b306/win32/src/win32event.i
--- pywin32-b306-orig/win32/src/win32event.i	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32event.i	2023-04-07 09:30:41.712132700 +0800
@@ -18,6 +18,7 @@
 
 // only seem able to make this work with an incorrect level of
 // indirection, and fixing it up inline with a temp.
+%typedef PTIMERAPCROUTINE PTIMERAPCROUTINE;
 %typemap(python,in) PTIMERAPCROUTINE *(PTIMERAPCROUTINE temp) {
 	if ($source != Py_None) {
 		PyErr_SetString(PyExc_TypeError, "This param must be None");
@@ -95,7 +96,6 @@
 BOOLAPI CancelWaitableTimer(PyHANDLE handle);
 #endif
 
-#end
 
 // @pyswig <o PyHANDLE>|CreateEvent|Creates a waitable event
 // @rdesc The result is a handle to the created object
@@ -399,7 +399,7 @@
     BOOL bAlertable 	// @pyparm bool|bAlertable||alertable wait flag.
    );
 #endif
-%typedef DWORD DWORD_WAITAPI
+%typedef DWORD DWORD_WAITAPI;
 %typemap(python,except) DWORD_WAITAPI {
       Py_BEGIN_ALLOW_THREADS
       $function
diff -urN pywin32-b306-orig/win32/src/win32evtlog.i pywin32-b306/win32/src/win32evtlog.i
--- pywin32-b306-orig/win32/src/win32evtlog.i	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32evtlog.i	2023-04-07 09:30:41.753152600 +0800
@@ -4,9 +4,18 @@
 // <nl>The Evt* functions are only available on Vista and later.  Attempting to call
 //	them on XP will result in the process exiting, rather than a python exception.
 
+%{
+#ifndef _MSC_VER
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x0600 // for EVT_SUBSCRIBE_NOTIFY_ACTION
+#endif
+%}
+
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef HANDLE EVT_HANDLE;
+
 %{
 
 #include <structmember.h>
diff -urN pywin32-b306-orig/win32/src/win32file.i pywin32-b306/win32/src/win32file.i
--- pywin32-b306-orig/win32/src/win32file.i	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32file.i	2023-04-07 09:30:41.783139900 +0800
@@ -48,7 +48,7 @@
 
 #include "winsock2.h"
 #include "mswsock.h"
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 #include "winbase.h"
 #include "assert.h"
 #include <stddef.h>
@@ -73,6 +73,9 @@
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef DCB DCB;
+%typedef COMMTIMEOUTS COMMTIMEOUTS;
+
 %{
 
 #include "datetime.h" // python's datetime header.
@@ -723,8 +726,8 @@
 		&obHandle, &obCreationTime, &obLastAccessTime, &obLastWriteTime, &UTCTimes))
 		return NULL;
 
-    if (!PyWinObject_AsHANDLE(obHandle, &hHandle))
-        return NULL;
+	if (!PyWinObject_AsHANDLE(obHandle, &hHandle))
+		return NULL;
 	if (obCreationTime != Py_None){
 		if (!PyWinObject_AsFILETIME(obCreationTime, &FileTime))
 			return NULL;
@@ -5356,7 +5359,7 @@
 
 	PyErr_Clear();
 	char *cpathin;
-	if (cpathin=PyBytes_AsString(obpathin)){
+	if (cpathin==PyBytes_AsString(obpathin)){
 		if (htrans)
 			CHECK_PFN(GetFullPathNameTransactedA);
 		char *cpathret=NULL, *cfilepart, *cpathsave=NULL;
diff -urN pywin32-b306-orig/win32/src/win32file_comm.cpp pywin32-b306/win32/src/win32file_comm.cpp
--- pywin32-b306-orig/win32/src/win32file_comm.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32file_comm.cpp	2023-04-07 09:30:41.989293800 +0800
@@ -163,7 +163,7 @@
 PyDCB::~PyDCB(void) {}
 
 #define GET_BITFIELD_ENTRY(bitfield_name) \
-    else if (strcmp(name, #bitfield_name) == 0) { return PyLong_FromLong(pydcb->m_DCB.##bitfield_name); }
+    else if (strcmp(name, #bitfield_name) == 0) { return PyLong_FromLong(pydcb->m_DCB.bitfield_name); }
 
 PyObject *PyDCB::getattro(PyObject *self, PyObject *obname)
 {
@@ -194,11 +194,11 @@
 #define SET_BITFIELD_ENTRY(bitfield_name)                                 \
     else if (strcmp(name, #bitfield_name) == 0)                           \
     {                                                                     \
-        if (!PyLong_Check(v)) {                                            \
+        if (!PyLong_Check(v)) {                                           \
             PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
             return -1;                                                    \
         }                                                                 \
-        pydcb->m_DCB.##bitfield_name = PyLong_AsLong(v);                   \
+        pydcb->m_DCB.bitfield_name = PyLong_AsLong(v);                    \
         return 0;                                                         \
     }
 
@@ -362,7 +362,7 @@
 
 #undef GET_BITFIELD_ENTRY
 #define GET_BITFIELD_ENTRY(bitfield_name) \
-    else if (strcmp(name, #bitfield_name) == 0) { return PyLong_FromLong(pyCOMSTAT->m_COMSTAT.##bitfield_name); }
+    else if (strcmp(name, #bitfield_name) == 0) { return PyLong_FromLong(pyCOMSTAT->m_COMSTAT.bitfield_name); }
 
 PyObject *PyCOMSTAT::getattro(PyObject *self, PyObject *obname)
 {
@@ -387,11 +387,11 @@
 #define SET_BITFIELD_ENTRY(bitfield_name)                                 \
     else if (strcmp(name, #bitfield_name) == 0)                           \
     {                                                                     \
-        if (!PyLong_Check(v)) {                                            \
+        if (!PyLong_Check(v)) {                                           \
             PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
             return -1;                                                    \
         }                                                                 \
-        pyCOMSTAT->m_COMSTAT.##bitfield_name = PyLong_AsLong(v);           \
+        pyCOMSTAT->m_COMSTAT.bitfield_name = PyLong_AsLong(v);            \
         return 0;                                                         \
     }
 
diff -urN pywin32-b306-orig/win32/src/win32gui.i pywin32-b306/win32/src/win32gui.i
--- pywin32-b306-orig/win32/src/win32gui.i	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32gui.i	2023-04-07 09:30:42.189189600 +0800
@@ -23,9 +23,20 @@
 %include "typemaps.i"
 %include "pywintypes.i"
 
+%typedef POINT POINT;
+%typedef RECT RECT;
+%typedef MSG MSG;
+%typedef TRACKMOUSEEVENT TRACKMOUSEEVENT;
+%typedef PAINTSTRUCT PAINTSTRUCT;
+%typedef ICONINFO ICONINFO;
+%typedef LOGFONT LOGFONT;
+%typedef MENUITEMINFO MENUITEMINFO;
+%typedef NOTIFYICONDATA NOTIFYICONDATA;
+%typedef OPENFILENAME OPENFILENAME;
+
 %{
 #undef PyHANDLE
-#include "pywinobjects.h"
+#include "PyWinObjects.h"
 #include "winuser.h"
 #include "commctrl.h"
 #include "windowsx.h" // For edit control hacks.
@@ -367,14 +378,14 @@
 }
 
 %apply COLORREF {long};
-typedef long COLORREF
+typedef long COLORREF;
 
 typedef HANDLE WPARAM;
 typedef HANDLE LPARAM;
 typedef HANDLE LRESULT;
 typedef int UINT;
 
-%typedef void *NULL_ONLY
+%typedef void *NULL_ONLY;
 
 %typemap(python,in) NULL_ONLY {
 	if ($source != Py_None) {
@@ -1750,9 +1761,9 @@
 %native (PyGetBufferAddressAndLen) PyGetBufferAddressAndLen;
 
 
-%typedef TCHAR *STRING_OR_ATOM_CW
-%typedef TCHAR *RESOURCE_ID
-%typedef TCHAR *RESOURCE_ID_NULLOK
+%typedef TCHAR *STRING_OR_ATOM_CW;
+%typedef TCHAR *RESOURCE_ID;
+%typedef TCHAR *RESOURCE_ID_NULLOK;
 
 %typemap(python,arginit) STRING_OR_ATOM_CW, RESOURCE_ID, RESOURCE_ID_NULLOK{
 	$target=NULL;
@@ -1816,12 +1827,12 @@
 		return NULL;
     // not on NT
 	HMODULE hmod = GetModuleHandle(_T("user32"));
-    BOOL (WINAPI *pfnFW)(PFLASHWINFO) = NULL;
-    if (hmod)
-        pfnFW = (BOOL (WINAPI *)(PFLASHWINFO))GetProcAddress(hmod, "FlashWindowEx");
-    if (pfnFW==NULL)
-        return PyErr_Format(PyExc_NotImplementedError,
-                            "FlashWindowsEx is not supported on this version of windows");
+	BOOL (WINAPI *pfnFW)(PFLASHWINFO) = NULL;
+	if (hmod)
+		pfnFW = (BOOL (WINAPI *)(PFLASHWINFO))GetProcAddress(hmod, "FlashWindowEx");
+	if (pfnFW==NULL)
+		return PyErr_Format(PyExc_NotImplementedError,
+			"FlashWindowsEx is not supported on this version of windows");
 	Py_BEGIN_ALLOW_THREADS
 	rc = (*pfnFW)(&f);
 	Py_END_ALLOW_THREADS
@@ -7676,13 +7687,13 @@
 				"structure says it has %d bytes, but %d was provided",
 				(int)struct_bytes, (int)pybuf.len());
 	// @pyseeapi RegisterDeviceNotification
-	HDEVNOTIFY not;
+	HDEVNOTIFY notify;
 	Py_BEGIN_ALLOW_THREADS
-	not = RegisterDeviceNotification(handle, pybuf.ptr(), flags);
+	notify = RegisterDeviceNotification(handle, pybuf.ptr(), flags);
 	Py_END_ALLOW_THREADS
-	if (not == NULL)
+	if (notify == NULL)
 		return PyWin_SetAPIError("RegisterDeviceNotification");
-	return PyWinObject_FromHDEVNOTIFY(not);
+	return PyWinObject_FromHDEVNOTIFY(notify);
 }
 %}
 %native(RegisterDeviceNotification) PyRegisterDeviceNotification;
diff -urN pywin32-b306-orig/win32/src/win32helpmodule.cpp pywin32-b306/win32/src/win32helpmodule.cpp
--- pywin32-b306-orig/win32/src/win32helpmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32helpmodule.cpp	2023-04-07 09:30:42.251187600 +0800
@@ -2546,13 +2546,11 @@
 
 // Module constants:
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 
 int AddConstants(PyObject *module)
 {
-    int rc;
-
 #ifdef _DEBUG
     int debug = 1;
 #else
@@ -3093,7 +3091,7 @@
     // @const win32help|HH_GPROPID_CONTENT_LANGUAGE|long: LandId for desired
     // content.
 
-    return rc;
+    return 0;
 }
 
 /* List of functions exported by this module */
diff -urN pywin32-b306-orig/win32/src/win32inet_winhttp.cpp pywin32-b306/win32/src/win32inet_winhttp.cpp
--- pywin32-b306-orig/win32/src/win32inet_winhttp.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32inet_winhttp.cpp	2023-04-07 09:30:42.277191800 +0800
@@ -6,8 +6,8 @@
 // The intent is to only wrap stuff which isn't otherwise doable from
 // Python, such as the proxy stuff.
 
-#include "pywintypes.h"
-#include "pywinobjects.h"
+#include "PyWinTypes.h"
+#include "PyWinObjects.h"
 #include "winhttp.h"
 
 // @doc
diff -urN pywin32-b306-orig/win32/src/win32lzmodule.cpp pywin32-b306/win32/src/win32lzmodule.cpp
--- pywin32-b306-orig/win32/src/win32lzmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32lzmodule.cpp	2023-04-07 09:30:42.289189100 +0800
@@ -11,7 +11,7 @@
 
 ******************************************************************/
 
-#include "Pywintypes.h"
+#include "PyWinTypes.h"
 #include "lzexpand.h"
 
 static PyObject *obHandleMap = NULL;
diff -urN pywin32-b306-orig/win32/src/win32net/win32netmisc.cpp pywin32-b306/win32/src/win32net/win32netmisc.cpp
--- pywin32-b306-orig/win32/src/win32net/win32netmisc.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32net/win32netmisc.cpp	2023-04-07 09:30:42.316178600 +0800
@@ -1418,7 +1418,8 @@
 
 #if WINVER >= 0x0500
 
-extern "C" NetValidateNamefunc pfnNetValidateName = NULL;
+extern "C" NetValidateNamefunc pfnNetValidateName;
+NetValidateNamefunc pfnNetValidateName = NULL;
 // @pymethod |win32net|NetValidateName|Checks that domain/machine/workgroup name is valid for given context
 // @rdesc Returns none if valid, exception if not
 // @comm If Account and Password aren't passed, current logon credentials are used
@@ -1461,8 +1462,10 @@
     return ret;
 }
 
-extern "C" NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy = NULL;
-extern "C" NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree = NULL;
+extern "C" NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy;
+NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy = NULL;
+extern "C" NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree;
+NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree = NULL;
 
 static void PyObject_CleanupAUTH_INPUT(NET_VALIDATE_AUTHENTICATION_INPUT_ARG *p)
 {
diff -urN pywin32-b306-orig/win32/src/win32pdhmodule.cpp pywin32-b306/win32/src/win32pdhmodule.cpp
--- pywin32-b306-orig/win32/src/win32pdhmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32pdhmodule.cpp	2023-04-07 09:30:42.335187600 +0800
@@ -1004,7 +1004,7 @@
     {                                                             \
         if (i < seqLen) {                                         \
             PyObject *subItem = PyTuple_GET_ITEM(flags_tuple, i); \
-            myCfg.cfg.##r = PyObject_IsTrue(subItem);             \
+            myCfg.cfg.r = PyObject_IsTrue(subItem);               \
         }                                                         \
     }
 
diff -urN pywin32-b306-orig/win32/src/win32process.i pywin32-b306/win32/src/win32process.i
--- pywin32-b306-orig/win32/src/win32process.i	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32process.i	2023-04-07 09:30:42.392190300 +0800
@@ -1630,6 +1630,7 @@
 	$target = PyWinLong_FromVoidPtr($source);
 }
 
+%typedef ULONG_PTR ULONG_PTR;
 
 // @pyswig long|VirtualAllocEx|
 LONG_VOIDPTR VirtualAllocEx(
diff -urN pywin32-b306-orig/win32/src/win32rasmodule.cpp pywin32-b306/win32/src/win32rasmodule.cpp
--- pywin32-b306-orig/win32/src/win32rasmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32rasmodule.cpp	2023-04-07 09:30:42.424182900 +0800
@@ -15,7 +15,7 @@
 #define WINVER 0x500
 #endif
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 #include "ras.h"
 #include "raserror.h"
 
@@ -549,7 +549,7 @@
         pNotification = NULL;
     }
     else if (PyCallable_Check(obCallback)) {
-        pNotification = PyRasDialFunc1;
+        pNotification = (LPVOID)PyRasDialFunc1;
         notType = 1;
     }
     else if (PyLong_Check(obCallback)) {
@@ -787,15 +787,15 @@
 // @pymethod string|win32ras|GetErrorString|Returns an error string for a RAS error code.
 static PyObject *PyRasGetErrorString(PyObject *self, PyObject *args)
 {
+    TCHAR buf[512];
     DWORD error;
-    DWORD rc;
+    DWORD rc = RasGetErrorString(error, buf, sizeof(buf) / sizeof(buf[0]));
     if (!PyArg_ParseTuple(args, "i:GetErrorString",
                           &error))  // @pyparm int|error||The error value being queried.
         return NULL;
 
-    TCHAR buf[512];
     // @pyseeapi RasGetErrorString
-    if (rc = RasGetErrorString(error, buf, sizeof(buf) / sizeof(buf[0])))
+    if (rc)
         return ReturnRasError("RasGetErrorString");
     return PyWinObject_FromTCHAR(buf);
 }
@@ -803,14 +803,14 @@
 // @pymethod |win32ras|HangUp|Terminates a remote access session.
 static PyObject *PyRasHangUp(PyObject *self, PyObject *args)
 {
-    DWORD rc;
     HRASCONN hras;
+    DWORD rc = RasHangUp(hras);
     if (!PyArg_ParseTuple(args, "O&:HangUp", PyWinObject_AsHANDLE,
                           &hras))  // @pyparm int|hras||The handle to the RAS connection to be terminated.
         return NULL;
 
     // @pyseeapi RasHangUp
-    if (rc = RasHangUp(hras))
+    if (rc)
         return ReturnRasError("RasHangup");
     Py_INCREF(Py_None);
     return Py_None;
@@ -823,7 +823,7 @@
     if (!PyArg_ParseTuple(args, "O&:IsHandleValid", PyWinObject_AsHANDLE,
                           &hras))  // @pyparm int|hras||The handle to the RAS connection being checked.
         return NULL;
-    BOOL bRet = (hras >= 0);
+    BOOL bRet = ((INT_PTR)hras >= 0);
     return PyBool_FromLong(bRet);
 }
 
@@ -929,7 +929,7 @@
     {NULL, NULL}};
 
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 #define ADD_ENUM(parta, partb)                                                 \
     if (rc = PyModule_AddIntConstant(module, #parta "_" #partb, parta::partb)) \
@@ -940,7 +940,6 @@
 
 static int AddConstants(PyObject *module)
 {
-    int rc;
     ADD_CONSTANT(RASCS_OpenPort);             // @const win32ras|RASCS_OpenPort|Constant for RAS state.
     ADD_CONSTANT(RASCS_PortOpened);           // @const win32ras|RASCS_PortOpened|Constant for RAS state.
     ADD_CONSTANT(RASCS_ConnectDevice);        // @const win32ras|RASCS_ConnectDevice|Constant for RAS state.
diff -urN pywin32-b306-orig/win32/src/win32security.i pywin32-b306/win32/src/win32security.i
--- pywin32-b306-orig/win32/src/win32security.i	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32security.i	2023-04-07 09:30:42.457185700 +0800
@@ -5,6 +5,7 @@
 %module win32security // An interface to the win32 security API's
 
 %{
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0600 // Vista!
 %}
 
@@ -76,7 +77,7 @@
 
 typedef PSecurityFunctionTableW (SEC_ENTRY *InitSecurityInterfacefunc)(void);
 static InitSecurityInterfacefunc pfnInitSecurityInterface=NULL;
-extern PSecurityFunctionTableW psecurityfunctiontable=NULL;
+PSecurityFunctionTableW psecurityfunctiontable=NULL;
 
 typedef BOOL (WINAPI *TranslateNamefunc)(LPCTSTR, EXTENDED_NAME_FORMAT, EXTENDED_NAME_FORMAT, LPTSTR, PULONG);
 static TranslateNamefunc pfnTranslateName=NULL;
@@ -89,20 +90,20 @@
 
 
 // function pointers used in win32security_sspi.cpp and win32security_ds.cpp
-extern DsBindfunc pfnDsBind=NULL;
-extern DsUnBindfunc pfnDsUnBind=NULL;
-extern DsGetSpnfunc pfnDsGetSpn=NULL;
-extern DsWriteAccountSpnfunc pfnDsWriteAccountSpn=NULL;
-extern DsFreeSpnArrayfunc pfnDsFreeSpnArray=NULL;
-extern DsGetDcNamefunc pfnDsGetDcName=NULL;
-extern DsCrackNamesfunc pfnDsCrackNames=NULL;
-extern DsListInfoForServerfunc pfnDsListInfoForServer=NULL;
-extern DsListServersForDomainInSitefunc pfnDsListServersForDomainInSite=NULL;
-extern DsListServersInSitefunc pfnDsListServersInSite=NULL;
-extern DsListSitesfunc pfnDsListSites=NULL;
-extern DsListDomainsInSitefunc pfnDsListDomainsInSite=NULL;
-extern DsListRolesfunc pfnDsListRoles=NULL;
-extern DsFreeNameResultfunc pfnDsFreeNameResult=NULL;
+DsBindfunc pfnDsBind=NULL;
+DsUnBindfunc pfnDsUnBind=NULL;
+DsGetSpnfunc pfnDsGetSpn=NULL;
+DsWriteAccountSpnfunc pfnDsWriteAccountSpn=NULL;
+DsFreeSpnArrayfunc pfnDsFreeSpnArray=NULL;
+DsGetDcNamefunc pfnDsGetDcName=NULL;
+DsCrackNamesfunc pfnDsCrackNames=NULL;
+DsListInfoForServerfunc pfnDsListInfoForServer=NULL;
+DsListServersForDomainInSitefunc pfnDsListServersForDomainInSite=NULL;
+DsListServersInSitefunc pfnDsListServersInSite=NULL;
+DsListSitesfunc pfnDsListSites=NULL;
+DsListDomainsInSitefunc pfnDsListDomainsInSite=NULL;
+DsListRolesfunc pfnDsListRoles=NULL;
+DsFreeNameResultfunc pfnDsFreeNameResult=NULL;
 
 static HMODULE advapi32_dll=NULL;
 static HMODULE secur32_dll =NULL;
@@ -114,8 +115,8 @@
 HMODULE loadmodule(WCHAR *dllname)
 {
 	HMODULE hmodule = GetModuleHandle(dllname);
-    if (hmodule==NULL)
-        hmodule = LoadLibrary(dllname);
+	if (hmodule==NULL)
+		hmodule = LoadLibrary(dllname);
 	return hmodule;
 }
 
@@ -3337,12 +3338,14 @@
 	if (PyWinObject_AsHANDLE(obExistingTokenHandle, &ExistingTokenHandle))
 		if (PyWinObject_AsSID_AND_ATTRIBUTESArray(obSidsToDisable, &SidsToDisable, &DisableSidCount))
 			if (PyWinObject_AsSID_AND_ATTRIBUTESArray(obSidsToRestrict, &SidsToRestrict, &RestrictedSidCount))
-				if (PyWinObject_AsLUID_AND_ATTRIBUTESArray(obPrivilegesToDelete, &PrivilegesToDelete, &DeletePrivilegeCount))
+				if (PyWinObject_AsLUID_AND_ATTRIBUTESArray(obPrivilegesToDelete, &PrivilegesToDelete, &DeletePrivilegeCount)){
 					if ((*pfnCreateRestrictedToken)(ExistingTokenHandle,Flags,DisableSidCount,SidsToDisable,
-							DeletePrivilegeCount,PrivilegesToDelete,RestrictedSidCount,SidsToRestrict,&NewTokenHandle))
+							DeletePrivilegeCount,PrivilegesToDelete,RestrictedSidCount,SidsToRestrict,&NewTokenHandle)){
 						ret=PyWinObject_FromHANDLE(NewTokenHandle);
-					else
+					}else{
 						PyWin_SetAPIError("CreateRestrictedToken",GetLastError());
+					}
+				}
 	if (SidsToDisable!=NULL)
 		free(SidsToDisable);
 	if (PrivilegesToDelete!=NULL)
diff -urN pywin32-b306-orig/win32/src/win32service.i pywin32-b306/win32/src/win32service.i
--- pywin32-b306-orig/win32/src/win32service.i	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32service.i	2023-04-07 09:30:42.479185200 +0800
@@ -3,9 +3,18 @@
 %module win32service // An interface to the Windows NT Service API
 
 
+%{
+#ifndef _MSC_VER
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x0600 // for SERVICE_*
+#endif
+%}
+
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef SERVICE_STATUS SERVICE_STATUS;
+
 %{
 #undef PyHANDLE
 #include "PyWinObjects.h"
diff -urN pywin32-b306-orig/win32/src/win32tsmodule.cpp pywin32-b306/win32/src/win32tsmodule.cpp
--- pywin32-b306-orig/win32/src/win32tsmodule.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32tsmodule.cpp	2023-04-07 09:30:42.494186700 +0800
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x501
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
diff -urN pywin32-b306-orig/win32/src/win32wnet/PyNCB.cpp pywin32-b306/win32/src/win32wnet/PyNCB.cpp
--- pywin32-b306-orig/win32/src/win32wnet/PyNCB.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32wnet/PyNCB.cpp	2023-04-07 09:30:42.533383100 +0800
@@ -17,9 +17,9 @@
  ******************************************************************/
 // @doc
 
-#include "Pywintypes.h"
+#include "PyWinTypes.h"
 #include <windows.h>
-#include "python.h"
+#include "Python.h"
 #include "PyNCB.h"
 
 #include <crtdbg.h>
diff -urN pywin32-b306-orig/win32/src/win32wnet/PyNetresource.cpp pywin32-b306/win32/src/win32wnet/PyNetresource.cpp
--- pywin32-b306-orig/win32/src/win32wnet/PyNetresource.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32wnet/PyNetresource.cpp	2023-04-07 09:30:42.547369500 +0800
@@ -18,7 +18,7 @@
 // @doc
 
 #include "PyWinTypes.h"
-#include "netres.h"  // C++ header file for NETRESOURCE object
+#include "Netres.h"  // C++ header file for NETRESOURCE object
 
 static PyObject *NETRESOURCE_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
 {
diff -urN pywin32-b306-orig/win32/src/win32wnet/win32wnet.cpp pywin32-b306/win32/src/win32wnet/win32wnet.cpp
--- pywin32-b306-orig/win32/src/win32wnet/win32wnet.cpp	2023-03-26 07:53:26.000000000 +0800
+++ pywin32-b306/win32/src/win32wnet/win32wnet.cpp	2023-04-07 09:30:42.566367800 +0800
@@ -38,8 +38,8 @@
 
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"  // for the PyHANDLE impl.
-#include "netres.h"        // NETRESOURCE Type
-#include "pyncb.h"
+#include "Netres.h"        // NETRESOURCE Type
+#include "PyNCB.h"
 
 /****************************************************************************
         HELPER FUNCTIONS
